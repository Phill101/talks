## Referential transparency

Note: "... Оно позволяет нам использовать математические абстракции, намного проще рассуждать о коде и делать огромное множетсво интересных вещей. Что же это такое? Проще всего понять это свойство на примере:"


```scala
val expr = 123
(expr, expr)
```
тоже что и
```scala
(123, 123)
```
Note: Результат: (123, 123). "...Метод подстановки..."


```scala
val expr = println("Hello!")
(expr, expr)
```
~~тоже что и~~
```scala
(println("Hello!"), println("Hello!"))
```

Note: Результат ((), ()) + 2 раза вывод в консоль!
"Выражение считается ссылочно-прозрачным если, для всех возможных программ, все упоминания этого выражения могут быть заменены результатом вычисления этого выражения, не изменяя смысла программы. Функция считается чистой, если при любых ссылочно-прозрачных аргументах, её результат ссылочно-прозрачен."
В идеале, мы бы хотели видеть как можно больше ссылочно-прозрачных выражений. О них намного проще рассуждать, их намного проще рефакторить, с ними проще оптимизировать (например в случаях мемоизации или ленвыих вычислений), они очень легко поддаются распаралеливанию. Всё становится детерминированным. Но вот проблема... Мы живём в реальном мире, где нам нужно: писать в консоль, ходить в базу данных и взаимодействовать с реальным миром. И хорошо бы нам это взаимодействие вынести куда-то как можно дальше, (часто говорят, на край мира) - желательно в main функцию. И как же это сделать?"


```scala
class IO[A](val unsafeInterpret: () => A) { s =>
  def map[B](f: A => B) = flatMap(f.andThen(IO(_)))

  def flatMap[B](f: A => IO[B]): IO[B] = 
    IO { f(s.unsafeInterpret()).unsafeInterpret() }
}
object IO {
  def apply[A](eff: => A) = new IO(() => eff)
}
```


```scala
def putStrLn(s: String): IO[Unit] = IO(println(s))
val readLn: IO[String] = IO(scala.io.StdIn.readLine())
```
```scala
val program: IO[Unit] = for {
  _    <- putStrLn("Hello, what is your name?")
  name <- readLn
  _    <- putStrLn(s"Glad to meet you, $name")
} yield ()
```
<!-- .element: class="fragment" data-fragment-index="1" -->
```scala
program.unsafeInterpret()
```
<!-- .element: class="fragment" data-fragment-index="2" -->
- <!-- .element: class="fragment" data-fragment-index="3" --> Композируемость
- <!-- .element: class="fragment" data-fragment-index="4" --> Local reasoning
- <!-- .element: class="fragment" data-fragment-index="5" --> Рефакторинг

Note: "Умные люди пришли к типу данных, цель которого - отложить вычисления"
"Это позволяет нам ссылочно-прозрачным образом описывать какие-то действия"
"IO это композируемая, ссылочно-прозрачная программа, которая будет выполнена где-то на краю мира"
"Это всего лишь идея" -> 'система эффектов' - нектоорый рантайм


```scala
trait Concurrent[F[_]] extends Async[F] {
  def start[A](fa: F[A]): F[Fiber[F, A]]
}

trait Fiber[F[_], A] {
  def cancel: F[Unit]
  def join: F[A]
}
```
```scala
def makeRequest(url: String): IO[Response]

for {
  fiber <- makeRequest(url).start
  _     <- putStrLn("something else here")
  resp  <- fiber.join
} yield resp

```
<!-- .element: class="fragment" data-fragment-index="1" -->

Note: "Concurrency в системах эффектов базируются на файберах, а не тредах операционной системы"
Файбер - хендлер конкуретно выполняющегося IO. join - семантически блокирующая операция.
Очень лёгкие и их можно создавать сколь угодно много.


```scala
def makeRequest(url: String): IO[Response]

for {
  fiber <- makeRequest(url).start
  _     <- putStrLn("something else here")
  _     <- fiber.cancel
} yield ???
```
```scala
val task1: IO[Int]
val task2: IO[Boolean]

val winner: Either[Int, Boolean] = IO.race(task1, task2)
```
<!-- .element: class="fragment" data-fragment-index="1" -->
```scala
val task: IO[Int]

for {
  f <- task.timeout(1.second).start
  _ <- putStrLn("waiting for a task")
  i <- f.join // fail-fast on timeout
  _ <- puStrLn(s"success: $i")
} yield ()
```
<!-- .element: class="fragment" data-fragment-index="2" -->
