## Referential transparency

Note: "Именно это свойство является фундаментом. Оно позволяет нам использовать математические абстракции, намного проще рассуждать о коде и делать огромное множетсво интересных вещей. Итак... Проще всего понять это свойство на примере:"


```scala
val expr = 123
(expr, expr)
```
тоже что и
```scala
(123, 123)
```
Note: "У нас есть некоторое выражение - 123. Используя его мы формируем тапл из двух интов. Совершенно логично, что мы можем перезаписать это выражение, использовав напрямую литерал 123. Мы просто использовали метод подстановки. Как когда-то в школе. Мы взяли значение нашего X и подставили в уравнение. Конечный результат остался прежним. Это всё ещё тапл2 из интов, значение каждого - 123."


```scala
val expr = println("Hello!")
(expr, expr)
```
~~тоже что и~~
```scala
(println("Hello!"), println("Hello!"))
```

Note: "Возьмём другое выражение и проделаем тоже самое. К сожалению, конечный результат разный. Во втором случае, в консоль выведется Hello 2 раза, а не 1. Дело в том, что функция println не является ссылочно-прозрачной, в то время как литерал 123 - является.

Выражение считается ссылочно-прозрачным если, для всех возможных программ, все упоминания этого выражения могут быть заменены результатом вычисления этого выражения, не изменяя смысла программы. Функция считается чистой, если при любых ссылочно-прозрачных аргументах, её результат ссылочно-прозрачен.

В идеале, мы бы хотели видеть как можно больше ссылочно-прозрачных выражений. О них намного проще рассуждать, их намного проще рефакторить, с ними проще оптимизировать (например в случаях мемоизации или ленвыих вычислений), они очень легко поддаются распаралеливанию. Всё становится детерминированным. Но вот проблема... Мы живём в реальном мире, где нам нужно: писать в консоль, ходить в базу данных и взаимодействовать с реальным миром. И хорошо бы нам это взаимодействие вынести куда-то как можно дальше, (часто говорят, на край мира) - желательно в main функцию. И как же это сделать?"


```scala
class IO[A](val unsafeInterpret: () => A) { s =>
  def map[B](f: A => B) = flatMap(f.andThen(IO(_)))

  def flatMap[B](f: A => IO[B]): IO[B] = 
    IO { f(s.unsafeInterpret()).unsafeInterpret() }
}
object IO {
  def apply[A](eff: => A) = new IO(() => eff)
}
```
```scala
def putStrLn(s: String): IO[Unit] = IO(println(s))
val readLn: IO[String] = IO(scala.io.StdIn.readLine())

val program: IO[Unit] = for {
  _    <- putStrLn("Hello, what is your name?")
  name <- readLn
  _    <- putStrLn(s"Glad to meet you, $name")
} yield ()
```
<!-- .element: class="fragment" data-fragment-index="1" -->

Note: "Умные люди пришли к типу данных, цель которого - отложить вычисления. Очевидна и монадичность такого типа данных. Т.к. мы хотим иметь последовательные вычисления - это было бы естественным. Самое главное, это позволяет нам ссылочно-прозрачным образом описывать какие-то действия. IO это композируемая, ссылочно-прозрачная программа, которая будет выполнена где-то на краю мира.
Однако, это всего лишь идея, верно? Вокруг неё построена 'система эффектов', ответственная за то КАК ИМЕННО всё это должно вычисляться. Это нектоорый рантайм, который берёт на себя эту задачу." 


```scala
trait Fiber[F[_], A] {
  def cancel: F[Unit]
  def join: F[A]
}
```

Note: "Concurrency в системах эффектов базируются на файберах, а не тредах операционной системы. Файбер это хендлер некоторого конкуретно выполняющегося IO. Его можно отменить, что прервёт выполнение такска. Его можно сджоинить и получить результат. Очевидно join - блокирующая операция. Но блокирующая семантически. Это значит, что реально никакой тред заблокирован не будет."
