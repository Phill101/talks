<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Про concurrency</title>

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">
		<!--<link rel="stylesheet" href="css/theme/white.css">-->

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">
    <!--<link rel="stylesheet" href="lib/css/idea.css">-->

		<!-- Printing and PDF exports -->
		<!-- <script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script> -->
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
        <section>
          <section>
            <h2>Про concurrency</h2>
          </section>
          <section>
            Сегодня
            <ol>
              <li class="fragment" data-fragment-index="0">Что предлагает нам императивный подход</li>
              <li class="fragment" data-fragment-index="1">Что предлагает нам функциональный подход</li>
              <ul>
                <li class="fragment" data-fragment-index="2">На чём базируется ФП</li>
                <li class="fragment" data-fragment-index="3">Особенности рантайма ФП</li>
                <li class="fragment" data-fragment-index="4">Собственный concurrency примитив</li>
                <li class="fragment" data-fragment-index="5">Затронем STM</li>
              </ul>
            </ol>
          </section>
        </section>
        <section>
          <section>
            <pre><code class="scala" data-trim data-line-numbers="|2|6-7">
class Auction(startsWith: Bid) {
  private var highest: Bid = startsWith

  def currentBidder: Long = highest.userId

  def makeBid(bid: Bid): Unit =
    if (bid.amount &gt; highest.amount) highest = bid
}
            </code></pre>
          </section>
          <section>
            <pre><code class="scala" data-trim data-line-numbers="|6-8" data-fragment-index="0">
class Auction(startsWith: Bid) {
  private var highest: Bid = startsWith

  def currentBidder: Long = highest.userId

  def makeBid(bid: Bid): Unit = this.synchronized {
    if (bid.amount &gt; highest.amount) highest = bid
  }
}
            </code></pre>
            <ul>
              <li class="fragment" data-fragment-index="1">Блокирует тред</li>
              <li class="fragment" data-fragment-index="2">Может привести к дедлоку</li>
              <li class="fragment" data-fragment-index="3">Тяжело рассуждать</li>
            </ul>
          </section>
          <section>
            todo картинка про актор
          </section>
          <section>
            <pre><code class="scala" data-trim data-line-numbers="|1-9|4-8|6-7" data-fragment-index="0">
class AuctionActor(startsWith: Bid) extends Actor {
  private var highest: Bid = startsWith

  override def receive: Actor.Receive = {
    case GetCurrentBidder =&gt; sender() ! highest.userId
    case MakeBid(b: Bid)  =&gt;
      if (b.amount &gt; highest.amount) highest = b
  }
}

object AuctionActor {
  case object GetCurrentBidder
  case class  MakeBid(bid: Bid)
}
            </code></pre>
            <ul>
              <li class="fragment" data-fragment-index="3">Тяжело тестировать и дебажить</li>
              <li class="fragment" data-fragment-index="4">Тяжело рассуждать</li>
            </ul>
          </section>
          <section>
            <pre><code class="scala" data-trim data-line-numbers="|2|6-10" data-fragment-index="0">
class Auction(startsWith: Bid) {
  private val highestRef = new AtomicReference(startsWith)

  def currentBidder: Long = highestRef.get.userId

  def makeBid(bid: Bid): Unit = 
    highestRef.updateAndGet { highest =&gt;
      if (bid.amount &gt; highest.amount) bid
      else highest
    }
}
            </code></pre>
            <ul>
              <li class="fragment" data-fragment-index="3">Side-effectful</li>
            </ul>
          </section>
          <section>
            <pre><code class="scala" data-trim data-line-numbers="|5" data-fragment-index="0">
import java.util.concurrent.Semaphore

val semaphore = new Semaphore(3)
semaphore.acquire(2)
semaphore.acquire(2)
            </code></pre>
            <ul>
              <li class="fragment" data-fragment-index="1">Мы можем лучше</li>
            </ul>
          </section>
        </section>
        <section data-background="#FFFFFF">
					<img src="content/conc-effects/pics/fpcat.jpg"/>
				</section>
        <section>
          <section>
            <h2>Referential transparency</h2>
          </section>
          <section>
            <pre><code class="scala" data-trim>
val expr = 123
(expr, expr)
            </code></pre>
            то же что и
            <pre><code class="scala" data-trim>
(123, 123)
            </code></pre>
          </section>
          <section>
            <pre><code class="scala" data-trim>
val expr = println("Hello!")
(expr, expr)
            </code></pre>
            <s>то же что и</s>
            <pre><code class="scala" data-trim>
(println("Hello!"), println("Hello!"))
            </code></pre>
            <aside class="notes">
              Выражение считается ссылочно-прозрачным если, для всех возможных программ, все упоминания этого выражения могут быть заменены результатом вычисления этого выражения, не изменяя смысла программы. Функция считается чистой, если при любых ссылочно-прозрачных аргументах, её результат ссылочно-прозрачен.
            </aside>
          </section>
          <section>
            <pre><code class="scala" data-trim data-line-numbers="|1,8|2,4-5">
class IO[A](val unsafeInterpret: () =&gt; A) { s =&gt;
  def map[B](f: A =&gt; B) = flatMap(f.andThen(IO(_)))

  def flatMap[B](f: A =&gt; IO[B]): IO[B] = 
    IO { f(s.unsafeInterpret()).unsafeInterpret() }
}
object IO {
  def apply[A](eff: =&gt; A) = new IO(() =&gt; eff)
}
            </code></pre>
          </section>
          <section>
            <pre><code class="scala" data-trim>
def putStrLn(s: String): IO[Unit] = IO(println(s))
val readLn: IO[String] = IO(scala.io.StdIn.readLine())
            </code></pre>
            <pre class="fragment" data-fragment-index="1"><code class="scala" data-trim>
val program: IO[Unit] = for {
  _    &lt;- putStrLn("Hello, what is your name?")
  name &lt;- readLn
  _    &lt;- putStrLn(s"Glad to meet you, $name")
} yield ()
            </code></pre>
            <pre class="fragment" data-fragment-index="2"><code class="scala" data-trim>
program.unsafeInterpret()
            </code></pre>
            <!--<ul>
              <li class="fragment" data-fragment-index="3">Композируемость</li>
              <li class="fragment" data-fragment-index="4">Local reasoning</li>
              <li class="fragment" data-fragment-index="5">Рефакторинг</li>
            </ul>-->
          </section>
          <section data-background="FFFFFF">
            <img src="content/conc-effects/pics/typeclasses-cheat-sheet.png"/>
          </section>
          <section>
            <pre><code class="scala" data-trim data-line-numbers="|1-3||2|5-8|7" data-fragment-index="0">
@typeclass trait Concurrent[F[_]] extends Async[F] {
  def start[A](fa: F[A]): F[Fiber[F, A]]
}

trait Fiber[F[_], A] {
  def cancel: F[Unit]
  def join: F[A]
}
            </code></pre>
            <pre class="fragment" data-fragment-index="1"><code class="scala" data-trim data-line-numbers="|4|4|6" data-fragment-index="2">
def makeRequest(url: String): IO[Response]

for {
  fiber &lt;- makeRequest(url).start
  _     &lt;- putStrLn("something else here")
  resp  &lt;- fiber.join
} yield resp
            </code></pre>
          </section>
          <section>
            <pre><code class="scala" data-trim data-line-numbers="|6" data-fragment-index="1">
def makeRequest(url: String): IO[Response]

for {
  fiber &lt;- makeRequest(url).start
  _     &lt;- putStrLn("something else here")
  _     &lt;- fiber.cancel
} yield ???
            </code></pre>
            <pre class="fragment" data-fragment-index="2"><code class="scala" data-trim data-line-numbers="|4" data-fragment-index="3">
val task1: IO[Int]
val task2: IO[Boolean]

val winner: Either[Int, Boolean] = IO.race(task1, task2)
            </code></pre>
            <pre class="fragment" data-fragment-index="4"><code class="scala" data-trim data-line-numbers="|4" data-fragment-index="5">
val task: IO[Int]

for {
  f &lt;- task.timeout(1.second).start
  _ &lt;- putStrLn("waiting for a task")
  i &lt;- f.join // fail-fast on timeout
  _ &lt;- puStrLn(s"success: $i")
} yield ()
            </code></pre>
          </section>
        </section>
        <section>
          <section>
            <pre><code class="scala" data-trim>
abstract class Ref[F[_], A] {
  def get: F[A]
  def set(a: A): F[Unit]
  def update(f: A =&gt; A): F[Unit]
  def modify[B](f: A =&gt; (A, B)): F[B]
  // ... and more
}

object Ref {
  def of[F[_]: Sync, A](a: A): F[Ref[F, A]]
}
            </code></pre>
            <pre class="fragment" data-fragment-index="2"><code class="scala" data-trim>
for {
  ref &lt;- Ref.of[IO, Int](42)
  v   &lt;- ref.get
  _   &lt;- putStrLn(s"value is: $v") // 'value is: 42'
  old &lt;- ref.modify(x =&gt; ((x + 1), x + "!"))
  nu  &lt;- ref.get
  _   &lt;- putStrLn(s"$old and $nu") // '42! and 43'
} yield ()
            </code></pre>
          </section>
          <section>
            <pre><code class="scala" data-trim>
class Auction private(highestRef: Ref[IO, Bid]) {
  def currentBidder: IO[Long] = highestRef.get.map(_.userId)

  def makeBid(bid: Bid): IO[Unit] = highestRef.update { highest =&gt;
    if (bid.amount &gt; highest.amount) bid
    else highest
  }
}

object Auction {
  def startWith(bid: Bid): IO[Auction] =
    Ref.of[IO, Bid](bid).map(new Auction(_))
}
            </code></pre>
          </section>
          <section>
            <pre><code class="scala" data-trim>
def putStrLn(s: Any): IO[Unit] = IO(println(s))

val io: IO[Unit] = for {
  semaphore &lt;- Semaphore[IO](3)
  f &lt;- semaphore.acquireN(2).start
  _ &lt;- semaphore.acquireN(2).timeout(1.second).start
  _ &lt;- IO.sleep(1.second) *&gt; semaphore.available &gt;&gt;= putStrLn
} yield ()
            </code></pre>
          </section>
          <section>
            <pre><code class="scala" data-trim>
abstract class Deferred[F[_], A] {    
  def get: F[A]    
  def complete(a: A): F[Unit]
}
            </code></pre>
            <pre class="fragment" data-fragment-index="1"><code class="scala" data-trim>
for {    
  d &lt;- Deferred[IO, Int]
  f &lt;- d.get.flatTap(i =&gt; putStrLn(s"completed with $i")).start
  _ &lt;- d.complete(42)
  i &lt;- f.join
} yield i
            </code></pre>
          </section>
        </section>

        <section>
          <section>
            <h2>Read write</h2>
            <pre><code class="scala" data-trim>
trait ReadWrite[F[_], A] {

  /** current value and release action*/
  def read:  F[(A, F[Unit])]

  /** current value and putAndRelease action*/
  def write: F[(A, A =&gt; F[Unit])]

}
            </code></pre>
            <pre class="fragment" data-fragment-index="1"><code class="scala" data-trim>
val io = for { 
  rw &lt;- ReadWrite.of[IO, Int](10) 
  (ten1, release1) &lt;- rw.read 
  _  &lt;- rw.write.timeout(1.second).attempt 
  (ten2, release2) &lt;- rw.read 
  _  &lt;- release1
  _  &lt;- release2
} yield (ten1, ten2)
            </code></pre>
          </section>
          <section>
            <pre><code class="scala" data-trim data-noescape>
final case class State[F[_], A](q: Queue[<span class="fragment" data-fragment-index="1">Op[F, A]</span>],
                                currentReaders: Int, 
                                writeLocked: Boolean, 
                                value: A)
            </code></pre>
            <pre class="fragment" data-fragment-index="1"><code class="scala" data-trim data-noescape>
sealed trait Op[F[_], A] {
  def isReader: Boolean = false
  def isWriter: Boolean = false
}

final case class Reader[F[_], A](d: Deferred[F, (A, F[Unit])]) extends Op[F, A] {
  override def isReader = true
}

final case class Writer[F[_], A](d: Deferred[F, (A, A =&gt; F[Unit])]) extends Op[F, A] {
  override def isWriter = true
}
            </code></pre>
          </section>
          <section>
            <pre><code class="scala" data-trim data-noescape>
object ReadWrite {

  final class ConcurrentReadWrite[F[_], A](state: Ref[F, State[F, A]])
                                 (implicit F: Concurrent[F]) extends ReadWrite[F, A] {

    override def read : F[(A, F[Unit])] = ???

    override def write: F[(A, A =&gt; F[Unit])] = ???

    private val releaseRead: F[Unit] = ???

    private def releaseWrite(a: A): F[Unit] = ???
  }

  def of[F[_]: Concurrent, A](value: A): F[ReadWrite[F, A]] = 
     Ref.of[F, State[F, A]](State(Queue.empty, 0, false, value))
       .map(new ConcurrentReadWrite[F, A](_))

}
            </code></pre>
          </section>
          <section>
            <pre><code class="scala" data-trim data-noescape>
override def read: F[(A, F[Unit])] = 
  Deferred[F, (A, F[Unit])]<span class="fragment" data-fragment-index="0">.<span class="fragment fade-in" style="position:absolute" data-fragment-index="7">bracketCase { d =&gt;</span><span class="fragment fade-out" data-fragment-index="7">flatMap { d =&gt;</span>
    <span class="fragment" data-fragment-index="1">state.modify {
      <span class="fragment" data-fragment-index="2">case s @ State(q, r, false, a) if q.isEmpty =&gt;</span>
        <span class="fragment" data-fragment-index="3">s.copy(currentReaders = r + 1) -&gt; d.complete(a -&gt; releaseRead)</span>
      <span class="fragment" data-fragment-index="4">case s @ State(q, _, _, _) =&gt; </span><span class="fragment" data-fragment-index="5">s.copy(q = q :+ Reader(d)) -&gt; F.unit</span>
    }</span><span class="fragment" data-fragment-index="3">.flatten</span><span class="fragment" data-fragment-index="6"> *&gt; d.get</span>
  } </span><span class="fragment" data-fragment-index="7">{
    <span class="fragment" data-fragment-index="8">case (d, ExitCase.Canceled | ExitCase.Error(_)) =&gt;</span>
      <span class="fragment" data-fragment-index="9">state.update(s =&gt; s.copy(q = s.q.filterNot(_ == Reader(d))))</span>
    <span class="fragment" data-fragment-index="10">case _ =&gt; F.unit</span>
  }</span>
            </code></pre>
            <pre class="fragment" data-fragment-index="11"><code class="scala" data-trim data-noescape>
private val releaseRead: F[Unit] = 
  state.modify {
    case s @ State(q, r, _, _) if q.isEmpty =&gt; 
      s.copy(currentReaders = r - 1) -&gt; F.unit
    case s @ State(Writer(d) +: tl, 1, _, a) =&gt; 
      s.copy(q = tl, currentReaders = 0, writeLocked = true) -&gt; 
        d.complete(a -&gt; releaseWrite)
    case s @ State(Writer(_) +: _, r, _, _) =&gt; 
      s.copy(currentReaders = r - 1) -&gt; F.unit
    case State(Reader(_) +: _, _, _, _) =&gt; 
      sys.error("wrong state. next in queue should be writer")
  }.flatten
            </code></pre>
          </section>
          <section>
            <pre><code class="scala" data-trim data-noescape>
override def write: F[(A, A =&gt; F[Unit])] = 
  Deferred[F, (A, A =&gt; F[Unit])].bracketCase { d =&gt;
    state.modify {
      case s @ State(q, 0, false, a) if q.isEmpty =&gt; 
        s.copy(wl = true) -&gt; d.complete(a -&gt; releaseWrite)
      case s @ State(q, _, _, _) =&gt; 
        s.copy(q = q :+ Writer(d)) -&gt; F.unit
    }.flatten *&gt; d.get
  } {
    case (d, ExitCase.Canceled | ExitCase.Error(_)) =&gt;
      state.update(s =&gt; s.copy(q = s.q.filterNot(_ == Writer(d))))
    case _ =&gt; F.unit
  }
            </code></pre>
            <pre class="fragment" data-fragment-index="1"><code class="scala" data-trim data-noescape>
private def releaseWrite(a: A): F[Unit] = 
  state.modify {
    case s @ State(q, _, _, _) if q.isEmpty  =&gt; 
      s.copy(value = a, wl = false) -&gt; F.unit
    case s @ State(Writer(d) +: tl, _, _, _) =&gt; 
      s.copy(q = tl, value = a) -&gt; d.complete(a -&gt; releaseWrite)
    case s @ State(q, _, _, _) =&gt;
      val nextReaders = q.iterator.takeWhile(_.isReader).collect {
        case Reader(d) =&gt; d.complete(a -&gt; releaseRead)
      }.toList
      val rCount = nextReaders.size

      s.copy(q = q.drop(rCount), value = a, wl = false, cr = rCount) -&gt;
        nextReaders.foldRight(F.unit)(_ *&gt; _)
  }.flatten
            </code></pre>
          </section>
          <section>
            <pre><code class="scala" data-trim data-noescape>
def get: F[A] = read.flatMap { 
  case (a, release) =&gt; release.as(a)
}

def set(a: A): F[A] = update(_ =&gt; a)
def update(f: A =&gt; A): F[Unit] = modify(a =&gt; (f(a), ()))
def modify(f: A =&gt; (A, B)) = write.flatMap {
  case (a, putAndrelease) =&gt;
    val (u, b) = f(a)
    putAndrelease(u).as(b)
}

def tryRead: F[Option(A, F[Unit])]
def tryGet: F[Option[A]]
...
            </code></pre>
          </section>
        </section>
        <section>
          <section>
            <h2>STM</h2>
          </section>
          <section>
            <pre><code class="scala" data-trim data-noescape>
def transfer(from  : Ref[Account], 
             to    : Ref[Account], 
             amount: Amount): IO[Unit] =
  if (from.get &gt;= amount) 
    from.update(_ - amount) *&gt; to.update(_ + amount)
  else 
    IO.sleep(1.second) *&gt; transfer(from, to, amount)
            </code></pre>
          </section>
          <section>
            <h2>Software Transactional Memory</h2>
          </section>
          <section>
            <pre><code class="scala" data-trim data-noescape>
def transfer(from  : TRef[Account], 
             to    : TRef[Account], 
             amount: Amount): STM[Unit] =
  for {
    balance &lt;- from.get
    if balance &gt;= amount // Or STM.check(balance &gt;= amount)
    _ &lt;- from.update(_ - amount)
    _ &lt;- to.update(_ + amount)
  } yield ()
            </code></pre>
            <pre class="fragment" data-fragment-index="0"><code class="scala" data-trim data-noescape>
def moneyTransfer(sender   : User, 
                  recipient: User, 
                  amount   : Amount): IO[Unit] =
  for {
    from &lt;- sender.account
    to   &lt;- recipient.account
    _    &lt;- transfer(from, to, amount).commit[IO]
  } yield ()
            </code></pre>
            <span class="fragment" data-fragment-index="1">Atomicity</span>
            <span class="fragment" data-fragment-index="2"> + Consistency</span>
            <span class="fragment" data-fragment-index="3"> + Isolation</span>
          </section>
          <section>
            <pre><code class="scala" data-trim data-noescape>
class TSemaphore private(val permits: TRef[Long]) {
  def acquireN(n: Long) =
    for {
      value &lt;- permits.get
      if value &gt;= n
      _ &lt;- permits.set(value - n)
    } yield ()

  def releaseN(n: Long) =
    permits.update(_ + n)
}

object TSemaphore {
  def make(n: Long) = TRef(n).map(new TSemaphore(_))
}
            </code></pre>
          </section>
        </section>
        <section>
          <h2>тут будут:</h2>
          <p>благодарности</p>
          <p>ссылки на ютуб</p>
          <p>ссылка на слайды</p>
        </section>
      </div>
		</div>

		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
        //width: '100%',
        //height: '100%',
				dependencies: [
					//{ src: 'plugin/markdown/marked.js' },
					//{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/highlight/highlight.js' },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});
		</script>
	</body>
</html>
